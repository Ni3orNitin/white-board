<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Laser Whiteboard - Auto Expanding Text</title>
    <style>
        body { 
            margin: 0; padding: 0; 
            background-color: #f8f9fa; 
            font-family: sans-serif;
            overflow: hidden; 
            user-select: none;
        }

        /* --- DRAG OVERLAY INDICATOR --- */
        body.drag-active canvas {
            border: 4px dashed #1971c2;
            box-sizing: border-box;
            background-color: rgba(231, 245, 255, 0.5);
        }

        /* --- SIDEBAR STYLES --- */
        .sidebar {
            position: fixed; top: 0; left: 0; bottom: 0; width: 60px;
            background: #fff; border-right: 1px solid #ddd;
            display: flex; flex-direction: column; align-items: center;
            padding-top: 10px; z-index: 2000; box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            transition: width 0.2s; overflow-y: auto; overflow-x: hidden;
        }
        .sidebar:hover { width: 220px; align-items: flex-start; }
        
        .board-list { width: 100%; display: flex; flex-direction: column; align-items: center; }
        .sidebar:hover .board-list { align-items: stretch; }

        .board-tab {
            width: 40px; height: 40px; margin: 5px 0;
            background: #f1f3f5; border-radius: 8px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: 0.2s; font-size: 14px; white-space: nowrap; overflow: hidden;
            flex-shrink: 0; position: relative;
        }
        .sidebar:hover .board-tab { 
            width: 90%; margin: 5px auto; justify-content: flex-start; padding-left: 10px; 
        }
        .board-tab:hover { background: #e9ecef; }
        .board-tab.active { background: #e7f5ff; border: 2px solid #1971c2; color: #1971c2; }
        
        .board-icon { font-size: 18px; min-width: 20px; text-align: center; }
        .board-name { 
            opacity: 0; margin-left: 10px; transition: 0.1s; pointer-events: none; 
            flex-grow: 1; text-overflow: ellipsis; overflow: hidden;
        }
        .sidebar:hover .board-name { opacity: 1; pointer-events: auto; }

        .btn-delete-board {
            display: none; color: red; font-weight: bold; padding: 5px; font-size: 16px; margin-right: 5px;
        }
        .sidebar:hover .btn-delete-board { display: block; }
        .btn-delete-board:hover { background: #ffe3e3; border-radius: 4px; }

        .add-board-btn {
            background: #40c057; color: white; border: none; width: 40px; height: 40px;
            border-radius: 50%; font-size: 24px; cursor: pointer; margin-top: 10px;
            display: flex; align-items: center; justify-content: center; align-self: center;
            flex-shrink: 0;
        }
        .add-board-btn:hover { background: #2f9e44; transform: scale(1.1); }

        /* --- CANVAS STYLES --- */
        canvas { 
            display: block; 
            width: 100vw; height: 100vh;
            background-color: #f8f9fa;
            background-image: radial-gradient(#d0d0d0 1.5px, transparent 1.5px);
            background-size: 24px 24px; 
            cursor: default;
            transform: translateZ(0);
        }

        .toolbar {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px);
            padding: 8px 16px; border-radius: 16px; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.05);
            display: flex; gap: 12px; align-items: center; z-index: 1000;
        }

        .tool-btn { background: transparent; border: none; cursor: pointer; padding: 10px; border-radius: 8px; font-size: 18px; color: #555; transition: 0.2s; }
        .tool-btn:hover { background-color: #f1f3f5; }
        .tool-btn.active { background-color: #e7f5ff; color: #1971c2; }
        
        .separator { width:1px; height: 24px; background: #eee; }
        input[type="range"] { accent-color: #1971c2; cursor: pointer; }
        input[type="color"] { border: none; width: 32px; height: 32px; cursor: pointer; background: none; }

        /* --- STORAGE METER STYLES --- */
        .storage-container {
            display: flex; flex-direction: column; align-items: center; gap: 2px;
        }
        .storage-label { font-size: 10px; color: #888; }
        .storage-bar-bg {
            width: 40px; height: 6px; background: #e9ecef; border-radius: 3px; overflow: hidden;
            border: 1px solid #ced4da;
        }
        #storage-bar {
            height: 100%; width: 0%; background-color: #40c057; transition: width 0.3s, background-color 0.3s;
        }

        /* --- NEW INPUT BOX STYLES --- */
        #temp-text-input {
            position: absolute;
            z-index: 9999;
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px dashed #1971c2;
            padding: 8px;
            
            /* GROWTH LOGIC */
            min-width: 50px;
            max-width: 500px;  /* Stops growing right at 500px, then wraps */
            width: fit-content;
            height: auto;
            
            outline: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-radius: 4px;
            font-family: sans-serif;
            font-size: 16px; 
            white-space: pre-wrap; /* Preserve spaces and line breaks */
            overflow: hidden; 
            line-height: 1.2;
            color: #000;
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <div id="board-list" class="board-list"></div>
        <button class="add-board-btn" onclick="addNewBoard()" title="New Board">+</button>
    </div>

    <input type="file" id="imageLoader" accept="image/png, image/jpeg, image/gif" style="display: none;"/>

    <div class="toolbar">
        <button class="tool-btn" onclick="saveBoard()" title="Save High-Res Notes">üíæ</button> 
        <div class="separator"></div>
        <button class="tool-btn active" id="btn-select" onclick="setTool('select')" title="Select (V)">üëÜ</button>
        <button class="tool-btn" id="btn-pan" onclick="setTool('pan')" title="Pan (Space)">‚úã</button>
        <div class="separator"></div>
        <button class="tool-btn" id="btn-text" onclick="setTool('text')" title="Text Tool">T</button>
        <button class="tool-btn" id="btn-pen" onclick="setTool('pen')" title="Pen (P)">‚úèÔ∏è</button>
        <button class="tool-btn" id="btn-arrow" onclick="setTool('arrow')" title="Doodle Arrow">‚ÜòÔ∏è</button>
        <button class="tool-btn" id="btn-laser" onclick="setTool('laser')" title="Smart Laser">üî¶</button>
        <button class="tool-btn" id="btn-rect" onclick="setTool('rect')" title="Rectangle">‚¨ú</button>
        <button class="tool-btn" id="btn-eraser" onclick="setTool('eraser')" title="Eraser">‚ö°</button>
        <button class="tool-btn" onclick="document.getElementById('imageLoader').click()" title="Add Image">üñºÔ∏è</button>
        
        <div class="separator"></div>
        <button class="tool-btn" onclick="duplicateSelection()" title="Duplicate (Ctrl+C / Ctrl+V)">üìÑ</button>
        
        <div class="separator"></div>
        <span style="font-size: 14px; color: #888;">üîé</span>
        <input type="range" id="zoom-slider" min="0.01" max="20.0" step="0.1" value="1.0">
        
        <div class="separator"></div>
        <input type="color" id="color-picker" value="#000000">
        <input type="range" id="line-width" min="2" max="20" value="3" style="width: 60px;">
        <button class="tool-btn" style="color: #e03131;" onclick="deleteSelected()">üóëÔ∏è</button>
        <button class="tool-btn" style="color: #c92a2a; font-weight: bold;" onclick="clearAllBoard()" title="Wipe Entire Board">‚ùå</button>
        
        <div class="separator"></div>
        <div class="storage-container" title="Local Storage Used">
            <div class="storage-bar-bg"><div id="storage-bar"></div></div>
            <span class="storage-label">Storage</span>
        </div>
    </div>

    <canvas id="board"></canvas>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        
        // --- MULTI-BOARD VARIABLES ---
        let boards = []; 
        let currentBoardId = null;

        // --- CAMERA STATE ---
        let cameraOffset = { x: 0, y: 0 };
        let cameraZoom = 1;
        const MAX_ZOOM = 20;          
        const MIN_ZOOM = 0.01;        
        const SCROLL_SENSITIVITY = 0.005;
        
        // --- APP STATE ---
        let elements = []; 
        let currentTool = 'select'; 
        let isDragging = false;
        let dragStartPos = {x:0, y:0};
        let currentDrawingShape = null; 
        
        // Selection
        let selectedElement = null; 
        let selectedGroup = [];     
        let resizeHandle = null; 
        
        // Drag Select
        let isSelectingBox = false;
        let selectionBoxStart = { x: 0, y: 0 };
        let currentSelectionBox = null;

        // Copy/Paste
        let clipboard = [];

        // Laser
        let laserTimer = null;         
        let activeLaserStrokes = [];   
        const LASER_TIMEOUT = 3000;    

        // Optimization
        let isRenderPending = false;
        let saveTimeout = null;

        const colorPicker = document.getElementById('color-picker');
        const lineWidthRange = document.getElementById('line-width');
        const zoomSlider = document.getElementById('zoom-slider');

        function resizeCanvas() { 
            canvas.width = window.innerWidth; 
            canvas.height = window.innerHeight; 
            scheduleRender(); 
        }
        window.addEventListener('resize', resizeCanvas);
        
        // --- AUTO LOAD ---
        initBoards();

        // --- OPTIMIZATION FUNCTIONS ---
        function scheduleRender() {
            if (!isRenderPending) {
                isRenderPending = true;
                requestAnimationFrame(() => {
                    render();
                    isRenderPending = false;
                });
            }
        }

        function triggerSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveCurrentBoard, 1000); 
        }

        // --- MULTI-BOARD LOGIC ---
        function initBoards() {
            try {
                const meta = localStorage.getItem('wb_boards_meta');
                if(meta) boards = JSON.parse(meta);
                else boards = [{id: Date.now(), name: "Main Board"}];

                const lastId = localStorage.getItem('wb_last_board');
                if(lastId && boards.find(b => b.id == lastId)) currentBoardId = parseInt(lastId);
                else currentBoardId = boards[0].id;
            } catch(e) {
                boards = [{id: Date.now(), name: "Main Board"}];
                currentBoardId = boards[0].id;
            }

            renderSidebar();
            loadBoardData(currentBoardId);
            resizeCanvas();
        }

        function renderSidebar() {
            const container = document.getElementById('board-list');
            container.innerHTML = '';
            boards.forEach(b => {
                const el = document.createElement('div');
                el.className = `board-tab ${b.id === currentBoardId ? 'active' : ''}`;
                el.onclick = () => switchBoard(b.id);
                el.ondblclick = (e) => renameBoard(e, b.id);
                el.innerHTML = `
                    <span class="board-icon">üìù</span>
                    <span class="board-name">${b.name}</span>
                    <span class="btn-delete-board" onclick="deleteBoard(event, ${b.id})">‚úñ</span>
                `;
                container.appendChild(el);
            });
            try {
                localStorage.setItem('wb_boards_meta', JSON.stringify(boards));
                localStorage.setItem('wb_last_board', currentBoardId);
                updateStorageMeter();
            } catch(e) {}
        }

        function switchBoard(id) {
            if(id === currentBoardId) return;
            saveCurrentBoard(); 
            currentBoardId = id;
            loadBoardData(id); 
            renderSidebar();
        }

        function addNewBoard() {
            saveCurrentBoard();
            const newId = Date.now();
            boards.push({id: newId, name: `Board ${boards.length + 1}`});
            currentBoardId = newId;
            elements = []; cameraOffset = {x:0, y:0}; cameraZoom = 1; zoomSlider.value=1;
            renderSidebar();
            scheduleRender();
        }

        function deleteBoard(e, id) {
            e.stopPropagation();
            if(boards.length <= 1) return;
            if(!confirm("Delete this board?")) return;
            localStorage.removeItem(`wb_data_${id}`);
            boards = boards.filter(b => b.id !== id);
            if(currentBoardId === id) {
                currentBoardId = boards[0].id;
                loadBoardData(currentBoardId);
            }
            renderSidebar();
        }

        function renameBoard(e, id) {
            e.stopPropagation();
            const name = prompt("Rename board:", "My Board");
            if(name) {
                const b = boards.find(b => b.id === id);
                if(b) b.name = name;
                renderSidebar();
            }
        }

        // --- STORAGE LOGIC ---
        function saveCurrentBoard() {
            const safeElements = elements.map(el => {
                if (el.type === 'image') return { ...el, img: null, imgSrc: el.img.src };
                return el;
            });
            const data = { elements: safeElements, cam: {x: cameraOffset.x, y: cameraOffset.y, z: cameraZoom} };
            try {
                localStorage.setItem(`wb_data_${currentBoardId}`, JSON.stringify(data));
                updateStorageMeter();
            } catch (e) {}
        }

        function loadBoardData(id) {
            try {
                const json = localStorage.getItem(`wb_data_${id}`);
                if(json) {
                    const data = JSON.parse(json);
                    if(data.cam) { cameraOffset = data.cam; cameraZoom = data.cam.z; zoomSlider.value = cameraZoom; }
                    if(data.elements) {
                        elements = data.elements.map(el => {
                            if (el.type === 'image' && el.imgSrc) {
                                const img = new Image(); img.src = el.imgSrc; img.onload = scheduleRender;
                                return { ...el, img: img };
                            }
                            return el;
                        });
                    }
                } else {
                    elements = []; cameraOffset = {x:0, y:0}; cameraZoom = 1; zoomSlider.value = 1;
                }
            } catch(e) { elements = []; }
            scheduleRender();
        }

        function updateStorageMeter() {
            try {
                let total = 0;
                for(let x in localStorage) {
                    if(localStorage.hasOwnProperty(x)) {
                        total += ((localStorage[x].length + x.length) * 2);
                    }
                }
                const limit = 5242880; 
                const percent = Math.min(100, (total / limit) * 100);
                const bar = document.getElementById('storage-bar');
                bar.style.width = percent + '%';
                if(percent > 90) bar.style.backgroundColor = '#fa5252'; 
                else if(percent > 70) bar.style.backgroundColor = '#fab005'; 
                else bar.style.backgroundColor = '#40c057'; 
            } catch(e) {}
        }

        function clearAllBoard() {
            if(confirm("This will permanently delete all notes on this board. Continue?")) {
                elements = []; selectedElement = null; selectedGroup = [];
                triggerSave();
                scheduleRender();
            }
        }

        // --- ZOOM & PAN ---
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.ctrlKey) {
                const zoomAmount = -e.deltaY * SCROLL_SENSITIVITY;
                const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, cameraZoom + zoomAmount));
                const mouseWorldBefore = getMousePos(e);
                cameraZoom = newZoom;
                cameraOffset.x = e.clientX - mouseWorldBefore.x * cameraZoom;
                cameraOffset.y = e.clientY - mouseWorldBefore.y * cameraZoom;
                zoomSlider.value = cameraZoom;
            } else {
                cameraOffset.x -= e.deltaX;
                cameraOffset.y -= e.deltaY;
            }
            scheduleRender(); 
            triggerSave();   
        }, { passive: false });

        zoomSlider.addEventListener('input', (e) => {
            const newZoom = parseFloat(e.target.value);
            const centerBefore = { x: window.innerWidth/2, y: window.innerHeight/2 };
            const worldCenter = { x: (centerBefore.x - cameraOffset.x)/cameraZoom, y: (centerBefore.y - cameraOffset.y)/cameraZoom };
            cameraZoom = newZoom;
            cameraOffset.x = centerBefore.x - worldCenter.x * cameraZoom;
            cameraOffset.y = centerBefore.y - worldCenter.y * cameraZoom;
            scheduleRender();
            triggerSave();
        });

        // --- SHORTCUTS ---
        window.addEventListener('keydown', (e) => {
            if (e.target.getAttribute('contenteditable') === 'true') return; // Ignore if editing text
            if ((e.ctrlKey || e.metaKey) && e.key === 'c') performCopy();
            if ((e.ctrlKey || e.metaKey) && e.key === 'v') performPaste();
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            if (e.code === 'Space' && currentTool !== 'pan_temp') {
                previousTool = currentTool;
                currentTool = 'pan_temp';
                canvas.style.cursor = 'grab';
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && currentTool === 'pan_temp') {
                currentTool = previousTool || 'select';
                setTool(currentTool);
            }
        });

        function getMousePos(e) { 
            return { x: (e.clientX - cameraOffset.x) / cameraZoom, y: (e.clientY - cameraOffset.y) / cameraZoom }; 
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const btn = document.getElementById(`btn-${tool}`);
            if(btn) btn.classList.add('active');
            const temp = document.getElementById('temp-text-input');
            if(temp) temp.remove();
            if (tool === 'pan' || tool === 'pan_temp') canvas.style.cursor = 'grab';
            else if (tool === 'select') canvas.style.cursor = 'default';
            else if (tool === 'text') canvas.style.cursor = 'text';
            else if (tool === 'eraser') canvas.style.cursor = 'not-allowed';
            else canvas.style.cursor = 'crosshair';
            if(tool !== 'select') { selectedElement = null; selectedGroup = []; scheduleRender(); }
        }

        // --- RENDER ---
        function render() {
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.fillStyle = "#f8f9fa";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            canvas.style.backgroundPosition = `${cameraOffset.x}px ${cameraOffset.y}px`;
            canvas.style.backgroundSize = `${24 * cameraZoom}px ${24 * cameraZoom}px`;
            
            ctx.translate(cameraOffset.x, cameraOffset.y);
            ctx.scale(cameraZoom, cameraZoom);
            
            // --- LAYER 1: IMAGES (ALWAYS BEHIND) ---
            elements.forEach(el => {
                if(el.type === 'image') drawElement(el, ctx);
            });

            // --- LAYER 2: EVERYTHING ELSE (Text, Pen, Arrows, Rects) ---
            elements.forEach(el => {
                if(el.type !== 'image') drawElement(el, ctx);
            });
            
            if (currentDrawingShape) drawElement(currentDrawingShape, ctx);
            if (selectedElement && currentTool === 'select') drawSelectionBox(selectedElement);
            if (selectedGroup.length > 0 && currentTool === 'select') drawGroupSelectionBox(selectedGroup);
            if (isSelectingBox && currentSelectionBox) drawDragSelectionBox();
        }

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const paragraphs = text.split('\n');
            let currentY = y;
            paragraphs.forEach(paragraph => {
                const words = paragraph.split(' ');
                let line = '';
                for(let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = context.measureText(testLine);
                    if (metrics.width > maxWidth && n > 0) {
                        context.fillText(line, x, currentY);
                        line = words[n] + ' ';
                        currentY += lineHeight;
                    } else { line = testLine; }
                }
                context.fillText(line, x, currentY);
                currentY += lineHeight;
            });
        }
        
        function drawElement(el, context) {
            context.globalAlpha = el.opacity !== undefined ? el.opacity : 1.0;
            context.beginPath();
            if (el.type === 'text') {
                const size = el.size || 16; 
                context.font = `${size}px sans-serif`; 
                context.fillStyle = el.color;
                context.textBaseline = "top";
                wrapText(context, el.text, el.x, el.y, el.w, size * 1.2); 
            }
            else if(el.type === 'pen' || el.type === 'rect' || el.type === 'laser' || el.type === 'arrow') {
                context.lineWidth = el.width;
                context.lineCap = 'round';
                context.lineJoin = 'round'; 
                context.strokeStyle = el.type === 'laser' ? 'red' : el.color;
                context.shadowBlur = (el.type === 'laser') ? 10 : 0;
                context.shadowColor = 'red';
                
                if (el.type === 'pen' || el.type === 'laser' || el.type === 'arrow') {
                    if(el.points.length < 1) return;
                    context.moveTo(el.points[0].x, el.points[0].y);
                    for (let i = 1; i < el.points.length; i++) context.lineTo(el.points[i].x, el.points[i].y);
                    context.stroke();
                    
                    // DOODLE ARROW HEAD LOGIC (STICK ARROW -> with 70% size)
                    if (el.type === 'arrow' && el.points.length > 1) {
                        const last = el.points[el.points.length - 1];
                        const prevIndex = Math.max(0, el.points.length - 5);
                        const prev = el.points[prevIndex];
                        
                        const angle = Math.atan2(last.y - prev.y, last.x - prev.x);
                        const headLen = 14; 

                        context.beginPath();
                        context.lineWidth = el.width;
                        context.lineCap = 'round';
                        context.strokeStyle = el.color;

                        // Wing 1
                        context.moveTo(last.x, last.y);
                        context.lineTo(last.x - headLen * Math.cos(angle - Math.PI / 6), last.y - headLen * Math.sin(angle - Math.PI / 6));
                        
                        // Wing 2
                        context.moveTo(last.x, last.y);
                        context.lineTo(last.x - headLen * Math.cos(angle + Math.PI / 6), last.y - headLen * Math.sin(angle + Math.PI / 6));
                        
                        context.stroke();
                        context.beginPath(); 
                    }

                } else if (el.type === 'rect') {
                    context.rect(el.x, el.y, el.w, el.h);
                    context.stroke();
                } 
            } else if (el.type === 'image') {
                context.shadowBlur = 0;
                if(el.img) context.drawImage(el.img, el.x, el.y, el.w, el.h);
            }
            context.shadowBlur = 0;
            context.globalAlpha = 1.0; 
        }

        function drawSelectionBox(el) {
            const s = 12 / cameraZoom; const lw = 2 / cameraZoom;
            ctx.strokeStyle = '#1971c2'; ctx.lineWidth = lw;
            const pad = el.type === 'text' ? 5 : 0;
            ctx.setLineDash([5, 5]); ctx.strokeRect(el.x-pad, el.y-pad, el.w+(pad*2), el.h+(pad*2)); ctx.setLineDash([]); 
            ctx.fillStyle = 'white'; ctx.strokeStyle = '#1971c2';
            const drawH = (x,y) => { ctx.beginPath(); ctx.arc(x, y, s/2, 0, 2*Math.PI); ctx.fill(); ctx.stroke(); }
            const bx = el.x-pad; const by = el.y-pad; const bw = el.w+(pad*2); const bh = el.h+(pad*2);
            drawH(bx, by); drawH(bx+bw, by); drawH(bx, by+bh); drawH(bx+bw, by+bh);
        }

        function drawGroupSelectionBox(group) {
            const box = getGroupBoundingBox(group);
            ctx.strokeStyle = '#1971c2'; ctx.lineWidth = 2/cameraZoom;
            ctx.setLineDash([5, 5]); ctx.strokeRect(box.x, box.y, box.w, box.h); ctx.setLineDash([]);
        }

        function drawDragSelectionBox() {
            ctx.fillStyle = "rgba(25, 113, 194, 0.1)";
            ctx.strokeStyle = "#1971c2"; ctx.lineWidth = 1 / cameraZoom; ctx.setLineDash([]);
            ctx.fillRect(currentSelectionBox.x, currentSelectionBox.y, currentSelectionBox.w, currentSelectionBox.h);
            ctx.strokeRect(currentSelectionBox.x, currentSelectionBox.y, currentSelectionBox.w, currentSelectionBox.h);
        }

        function getGroupBoundingBox(group) {
            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            group.forEach(el => {
                if(el.x < minX) minX = el.x; if(el.y < minY) minY = el.y;
                if(el.x + el.w > maxX) maxX = el.x + el.w; if(el.y + el.h > maxY) maxY = el.y + el.h;
            });
            const pad = 10;
            return { x: minX-pad, y: minY-pad, w: (maxX-minX)+pad*2, h: (maxY-minY)+pad*2 };
        }

        // --- COPY & PASTE ---
        function deepCloneElement(el) {
            const clone = { ...el };
            if(el.points) clone.points = el.points.map(p => ({x: p.x, y: p.y}));
            if(el.type === 'image') clone.img = el.img; 
            return clone;
        }
        function performCopy() {
            clipboard = [];
            if(selectedElement) clipboard.push(deepCloneElement(selectedElement));
            else if(selectedGroup.length > 0) clipboard = selectedGroup.map(el => deepCloneElement(el));
        }
        function performPaste() {
            if(clipboard.length === 0) return;
            const offset = 30 / cameraZoom;
            const newElements = clipboard.map(el => {
                const clone = deepCloneElement(el);
                clone.x += offset; clone.y += offset;
                if(clone.points) clone.points.forEach(p => { p.x += offset; p.y += offset; });
                elements.push(clone); return clone;
            });
            if(newElements.length === 1) { selectedElement = newElements[0]; selectedGroup = []; }
            else { selectedElement = null; selectedGroup = newElements; }
            clipboard = newElements.map(el => deepCloneElement(el));
            triggerSave(); scheduleRender();
        }
        function duplicateSelection() { performCopy(); performPaste(); }

        // --- INTERACTION ---
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1 || currentTool === 'pan' || currentTool === 'pan_temp') {
                isDragging = true; dragStartPos = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing';
                if(currentTool !== 'pan') { previousTool = currentTool; currentTool = 'pan_temp'; }
                return;
            }
            if (currentTool === 'text') return; 
            isDragging = true; const m = getMousePos(e); dragStartPos = {x: m.x, y: m.y}; 
            if (currentTool === 'select') {
                if(selectedElement) { resizeHandle = getHitHandle(selectedElement, m.x, m.y); if(resizeHandle) return; }
                if (selectedGroup.length > 0) {
                    const box = getGroupBoundingBox(selectedGroup);
                    if (m.x >= box.x && m.x <= box.x + box.w && m.y >= box.y && m.y <= box.y + box.h) return;
                }
                const hit = findElementUnderMouse(m.x, m.y);
                if (hit) {
                    if (hit.type === 'text' || hit.type === 'image' || hit.type === 'rect') { selectedGroup = []; selectedElement = hit; } 
                    else { selectedElement = null; selectedGroup = [hit]; }
                    elements = elements.filter(el => el !== hit); elements.push(hit); scheduleRender(); return;
                }
                selectedElement = null; selectedGroup = [];
                isSelectingBox = true; selectionBoxStart = { x: m.x, y: m.y }; currentSelectionBox = { x: m.x, y: m.y, w: 0, h: 0 };
                scheduleRender(); return;
            }
            if (currentTool === 'eraser') { deleteShapeAt(m.x, m.y); return; }
            if (currentTool === 'pen' || currentTool === 'laser' || currentTool === 'arrow') {
                currentDrawingShape = { type: currentTool, points: [{x: m.x, y: m.y}], color: colorPicker.value, width: lineWidthRange.value, opacity: 1.0 };
                if (currentTool === 'laser') clearTimeout(laserTimer);
            } else if (currentTool === 'rect') {
                currentDrawingShape = { type: 'rect', x: m.x, y: m.y, w: 0, h: 0, color: colorPicker.value, width: lineWidthRange.value };
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if ((currentTool === 'pan' || currentTool === 'pan_temp') && isDragging) {
                cameraOffset.x += e.clientX - dragStartPos.x; cameraOffset.y += e.clientY - dragStartPos.y;
                dragStartPos = { x: e.clientX, y: e.clientY }; scheduleRender(); return;
            }
            const m = getMousePos(e);
            if(currentTool === 'select' && selectedElement && !isDragging) {
                const h = getHitHandle(selectedElement, m.x, m.y); canvas.style.cursor = h ? 'pointer' : 'default';
            }
            if (!isDragging) return;
            const dx = m.x - dragStartPos.x; const dy = m.y - dragStartPos.y;
            if (currentTool === 'select') {
                if (isSelectingBox) { currentSelectionBox.w = m.x - selectionBoxStart.x; currentSelectionBox.h = m.y - selectionBoxStart.y; scheduleRender(); return; }
                if (selectedGroup.length > 0) {
                    selectedGroup.forEach(el => { el.x += dx; el.y += dy; if(el.points) el.points.forEach(p => { p.x += dx; p.y += dy; }); });
                    dragStartPos = {x: m.x, y: m.y}; scheduleRender(); return;
                }
                if (selectedElement) {
                    if(resizeHandle) {
                        const min = 20;
                        const oldH = selectedElement.h;
                        
                        if(resizeHandle==='br'){selectedElement.w=Math.max(min,selectedElement.w+dx);selectedElement.h=Math.max(min,selectedElement.h+dy);}
                        else if(resizeHandle==='bl'){const nw=selectedElement.w-dx;if(nw>min){selectedElement.x+=dx;selectedElement.w=nw;}selectedElement.h=Math.max(min,selectedElement.h+dy);}
                        else if(resizeHandle==='tr'){const nh=selectedElement.h-dy;if(nh>min){selectedElement.y+=dy;selectedElement.h=nh;}selectedElement.w=Math.max(min,selectedElement.w+dx);}
                        else if(resizeHandle==='tl'){const nw=selectedElement.w-dx;const nh=selectedElement.h-dy;if(nw>min){selectedElement.x+=dx;selectedElement.w=nw;}if(nh>min){selectedElement.y+=dy;selectedElement.h=nh;}}
                        
                        // TEXT RESIZE LOGIC
                        if(selectedElement.type === 'text') {
                            const ratio = selectedElement.h / oldH;
                            selectedElement.size = (selectedElement.size || 16) * ratio; /* CHANGED BASE TO 16 */
                        }

                    } else { selectedElement.x += dx; selectedElement.y += dy; }
                    dragStartPos = {x: m.x, y: m.y}; scheduleRender(); return;
                }
            }
            if (currentTool === 'eraser') { deleteShapeAt(m.x, m.y); return; }
            if (currentTool === 'pen' || currentTool === 'laser' || currentTool === 'arrow') currentDrawingShape.points.push({x: m.x, y: m.y});
            else if (currentTool === 'rect') { 
                currentDrawingShape.w = m.x - currentDrawingShape.x; 
                currentDrawingShape.h = m.y - currentDrawingShape.y; 
            }
            scheduleRender();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            if (isSelectingBox) {
                isSelectingBox = false;
                const bx = currentSelectionBox.w > 0 ? currentSelectionBox.x : currentSelectionBox.x + currentSelectionBox.w;
                const by = currentSelectionBox.h > 0 ? currentSelectionBox.y : currentSelectionBox.y + currentSelectionBox.h;
                const bw = Math.abs(currentSelectionBox.w); const bh = Math.abs(currentSelectionBox.h);
                selectedGroup = elements.filter(el => {
                    if (el.type !== 'pen' && el.type !== 'laser' && el.type !== 'arrow') return false; 
                    const cx = el.x + el.w/2; const cy = el.y + el.h/2;
                    return (cx >= bx && cx <= bx + bw && cy >= by && cy <= by + bh);
                });
                currentSelectionBox = null; scheduleRender(); return;
            }
            if(currentTool === 'pan_temp') { currentTool = previousTool || 'select'; setTool(currentTool); triggerSave(); }
            if(currentTool === 'pan') { canvas.style.cursor = 'grab'; triggerSave(); }
            resizeHandle = null;
            if(currentDrawingShape) {
                if((currentDrawingShape.type === 'rect') && Math.abs(currentDrawingShape.w) < 5 && Math.abs(currentDrawingShape.h) < 5) return;
                const finalShape = currentDrawingShape;
                if(finalShape.type === 'pen' || finalShape.type === 'laser' || finalShape.type === 'arrow') {
                    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
                    finalShape.points.forEach(p => { if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x; if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y; });
                    finalShape.x = minX; finalShape.y = minY; finalShape.w = maxX - minX; finalShape.h = maxY - minY;
                }
                elements.push(finalShape);
                if (finalShape.type === 'laser') {
                    activeLaserStrokes.push(finalShape); clearTimeout(laserTimer);
                    laserTimer = setTimeout(startFadingGroup, LASER_TIMEOUT);
                }
                currentDrawingShape = null; triggerSave(); scheduleRender();
            } else if (currentTool === 'select') { triggerSave(); }
        });

        // --- HELPERS ---
        function deleteShapeAt(x, y) {
             for (let i = elements.length - 1; i >= 0; i--) {
                const el = elements[i];
                if(el.type === 'image' || el.type === 'text') continue; 
                let hit = false;
                if (el.type === 'rect') {
                    const bx = el.w > 0 ? el.x : el.x + el.w;
                    const by = el.h > 0 ? el.y : el.y + el.h;
                    const bw = Math.abs(el.w); const bh = Math.abs(el.h);
                    hit = (x >= bx && x <= bx + bw && y >= by && y <= by + bh);
                }
                else if (el.type === 'pen' || el.type === 'laser' || el.type === 'arrow') hit = el.points.some(p => Math.hypot(p.x - x, p.y - y) < 10/cameraZoom);
                if (hit) { elements.splice(i, 1); triggerSave(); scheduleRender(); break; }
            }
        }
        function deleteSelected() {
            if (selectedElement) { elements = elements.filter(el => el !== selectedElement); selectedElement = null; }
            if (selectedGroup.length > 0) { elements = elements.filter(el => !selectedGroup.includes(el)); selectedGroup = []; }
            triggerSave(); scheduleRender();
        }
        
        function findElementUnderMouse(x, y) {
            // Helper for hit detection
            const isHit = (el) => {
                if(el.points) { 
                    return el.points.some(p => Math.hypot(p.x - x, p.y - y) < 10/cameraZoom); 
                } 
                else { 
                    const bx = el.w > 0 ? el.x : el.x + el.w;
                    const by = el.h > 0 ? el.y : el.y + el.h;
                    const bw = Math.abs(el.w);
                    const bh = Math.abs(el.h);
                    const pad = (el.type === 'text') ? 5 : 0; 
                    return (x >= bx-pad && x <= bx + bw+pad && y >= by-pad && y <= by + bh+pad); 
                }
            };

            // Pass 1: Check Foreground (Drawing, Text, Rects)
            for (let i = elements.length - 1; i >= 0; i--) {
                if (elements[i].type !== 'image' && isHit(elements[i])) return elements[i];
            }
            
            // Pass 2: Check Background (Images)
            for (let i = elements.length - 1; i >= 0; i--) {
                if (elements[i].type === 'image' && isHit(elements[i])) return elements[i];
            }
            return null;
        }

        function getHitHandle(el, x, y) {
            if(el.type === 'pen' || el.type === 'laser' || el.type === 'arrow') return null;
            const pad = 5; const s = 15 / cameraZoom; 
            const bx = el.x-pad; const by = el.y-pad; const bw = el.w+(pad*2); const bh = el.h+(pad*2);
            if(x>=bx-s && x<=bx+s && y>=by-s && y<=by+s) return 'tl'; 
            if(x>=bx+bw-s && x<=bx+bw+s && y>=by-s && y<=by+s) return 'tr';
            if(x>=bx-s && x<=bx+s && y>=by+bh-s && y<=by+bh+s) return 'bl'; 
            if(x>=bx+bw-s && x<=bx+bw+s && y>=by+bh-s && y<=by+bh+s) return 'br';
            return null;
        }
        function startFadingGroup() {
            const strokes = [...activeLaserStrokes]; activeLaserStrokes = [];
            function step() {
                let visible = false; strokes.forEach(s => { s.opacity -= 0.02; if(s.opacity > 0) visible = true; });
                scheduleRender(); if(visible) requestAnimationFrame(step); else { elements = elements.filter(el => !strokes.includes(el)); scheduleRender(); }
            } step();
        }

        // --- NEW AUTO-EXPANDING TEXT INPUT ---
        canvas.addEventListener('click', (e) => { 
            if (currentTool === 'text') {
                spawnTextInput(e.clientX, e.clientY, "", 250, 40, colorPicker.value); 
            }
        });
        canvas.addEventListener('dblclick', (e) => {
            const m = getMousePos(e); const hit = findElementUnderMouse(m.x, m.y);
            if (hit && hit.type === 'text') {
                elements = elements.filter(el => el !== hit); scheduleRender();
                const screenX = (hit.x * cameraZoom) + cameraOffset.x; const screenY = (hit.y * cameraZoom) + cameraOffset.y;
                spawnTextInput(screenX, screenY, hit.text, hit.w * cameraZoom, hit.h * cameraZoom, hit.color);
            }
        });
        
        function spawnTextInput(screenX, screenY, initialText, w, h, color) {
            const temp = document.getElementById('temp-text-input'); if(temp) temp.remove();
            
            // Create DIV instead of TEXTAREA
            const input = document.createElement('div'); 
            input.id = 'temp-text-input';
            input.contentEditable = true; // Key for auto-expanding
            
            input.style.left = screenX + 'px'; 
            input.style.top = screenY + 'px';
            input.style.color = color; 
            input.innerText = initialText;

            // If editing existing text, respect its width initially, else let it grow
            // We use minWidth to prevent it being invisible
            if (!initialText) {
                input.style.minWidth = '50px';
            }

            document.body.appendChild(input); 
            
            // Focus and Select All logic
            setTimeout(() => { 
                input.focus();
                // Move cursor to end
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(input);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
            }, 10);
            
            const m = getMousePos({clientX: screenX, clientY: screenY});
            
            const save = () => {
                const textContent = input.innerText;
                if(textContent.trim() !== "") {
                    // Capture final dimensions of the DIV
                    const finalW = input.offsetWidth;
                    const finalH = input.offsetHeight;
                    
                    elements.push({ 
                        type: 'text', 
                        text: textContent, 
                        x: m.x, 
                        y: m.y, 
                        color: color, 
                        w: finalW, 
                        h: finalH, 
                        size: 16 
                    });
                    triggerSave(); scheduleRender();
                } 
                if(input.parentNode) input.remove();
            };
            
            // Save on click away
            input.addEventListener('blur', save); 
            input.addEventListener('click', (ev) => ev.stopPropagation());
        }

        // --- SMART MAX QUALITY SAVE ---
        function saveBoard() {
            if (elements.length === 0) return;
            let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
            elements.forEach(el => {
                if(el.type === 'pen' || el.type === 'laser' || el.type === 'arrow') { if(el.points) el.points.forEach(p=>{ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }); } 
                else { if(el.x < minX) minX = el.x; if(el.y < minY) minY = el.y; if(el.x+el.w > maxX) maxX = el.x+el.w; if(el.y+el.h > maxY) maxY = el.y+el.h; }
            });
            if(minX === Infinity) { minX=0; maxX=100; minY=0; maxY=100; }
            const pad = 50; const w = (maxX - minX) + pad*2; const h = (maxY - minY) + pad*2;
            const MAX_PIXELS = 10000 * 10000; 
            const MAX_DIM = 16000; 
            let scale = 4; 
            while ((w * scale > MAX_DIM || h * scale > MAX_DIM || (w * scale * h * scale) > MAX_PIXELS) && scale > 1) {
                scale -= 0.5; 
            }
            const tCanvas = document.createElement('canvas');
            tCanvas.width = w * scale; tCanvas.height = h * scale; 
            const tCtx = tCanvas.getContext('2d');
            tCtx.scale(scale, scale); tCtx.translate(-(minX-pad), -(minY-pad));
            tCtx.fillStyle = 'white'; tCtx.fillRect(minX-pad, minY-pad, w, h);
            
            // --- DRAW IMAGES (BACKGROUND) ---
            elements.forEach(el => { if(el.type === 'image') drawElement(el, tCtx); });
            // --- DRAW REST (FOREGROUND) ---
            elements.forEach(el => { if(el.type !== 'image') drawElement(el, tCtx); });

            const link = document.createElement('a'); link.download = 'whiteboard.png'; link.href = tCanvas.toDataURL(); link.click();
        }

        // --- DRAG AND DROP (EXTERNAL FILES) ---
        const dropArea = document.body;
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        ['dragenter', 'dragover'].forEach(eventName => { dropArea.addEventListener(eventName, highlight, false); });
        ['dragleave', 'drop'].forEach(eventName => { dropArea.addEventListener(eventName, unhighlight, false); });
        function highlight(e) { dropArea.classList.add('drag-active'); }
        function unhighlight(e) { dropArea.classList.remove('drag-active'); }
        dropArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer; const files = dt.files; handleFiles(files, e.clientX, e.clientY);
        }

        function handleFiles(files, dropX, dropY) {
            ([...files]).forEach(file => {
                if(file.type.startsWith('image/')) {
                    const reader = new FileReader(); reader.readAsDataURL(file);
                    reader.onloadend = function() {
                        const img = new Image(); img.src = reader.result;
                        img.onload = function() {
                            const worldPos = { x: (dropX - cameraOffset.x) / cameraZoom, y: (dropY - cameraOffset.y) / cameraZoom };
                            const scale = Math.min(250/img.width, 1);
                            elements.push({
                                type: 'image', img: img,
                                x: worldPos.x - (img.width*scale)/2, y: worldPos.y - (img.height*scale)/2,
                                w: img.width * scale, h: img.height * scale
                            });
                            triggerSave(); setTool('select'); scheduleRender();
                        }
                    }
                }
            });
        }

        document.getElementById('imageLoader').addEventListener('change', (e) => {
            const r = new FileReader(); r.onload = (evt) => {
                const img = new Image(); img.onload = () => {
                    const scale = Math.min(250/img.width, 1);
                    const cx = (-cameraOffset.x + window.innerWidth/2)/cameraZoom; const cy = (-cameraOffset.y + window.innerHeight/2)/cameraZoom;
                    elements.push({type: 'image', img: img, x: cx-100, y: cy-100, w: img.width*scale, h: img.height*scale});
                    triggerSave(); setTool('select'); scheduleRender();
                }; img.src = evt.target.result;
            }; r.readAsDataURL(e.target.files[0]); e.target.value = '';
        });

        function clearAll() { elements = []; selectedElement = null; selectedGroup = []; scheduleRender(); }
        setTool('select');
    </script>
</body>
</html>